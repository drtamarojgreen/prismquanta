This incident highlighted several important development lessons:

1.  **Environment Configuration:**
    *   Storing configuration files in a centralized and easily accessible location is crucial. Moving `environment.txt` to the project root from a subdirectory simplified path management and reduced complexity in the scripts.
    *   When scripts need to be run from different directories, it's important to have a robust way to determine the project root. The `PRISM_QUANTA_ROOT` environment variable, set by a dedicated `setup_environment.sh` script, provides a reliable way to do this.

2.  **Script Portability:**
    *   Scripts should not rely on the current working directory to locate files. Using absolute paths based on a project root variable makes scripts more portable and less prone to errors.
    *   Hardcoding relative paths like `../` or `./` can lead to issues when scripts are run from unexpected locations.

3.  **Dependency Management:**
    *   The `code_analysis.sh` script failed because the `bc` command was not installed. This highlights the importance of identifying and documenting all script dependencies.

4.  **Error Handling and Debugging:**
    *   The `set -u` option in the scripts was helpful in identifying unbound variables, but it also made the scripts more brittle. It's important to find a balance between strict error checking and script robustness.
    *   Adding debug statements (e.g., `echo` commands to print variable values) was a useful technique for identifying issues with variable expansion and pathing.

5.  **Testing:**
    *   Creating a dedicated test script (`test_jules.sh`) was a good way to verify the fixes and ensure that the scripts work as expected. This is a good practice to follow for any future development.

[LESSON LEARNED]
Date: 2024-05-21 12:00:00
Topic: Dangers of Overly Broad Cleanup Logic in Automation Scripts

Occurrence:
A demonstration script (test_gemini.sh) was implemented with an overly aggressive cleanup function. The function was configured to remove entire project directories (e.g., /logs, /memory, /config) using 'rm -rf'. This was intended to reset the environment but had the severe side effect of deleting persistent project data, including configuration files and historical logs.

Remediation:
The cleanup logic was refactored to be highly specific. Instead of deleting directories, the script now maintains a list of the exact temporary files and file patterns (e.g., response_*.txt) it generates. The cleanup function iterates through this list, removing only the specified items. This surgical approach ensures that the script's cleanup process is non-destructive to the project's integrity and only affects files created during its own execution. This prevents data loss and makes the automation safer and more reliable.

[LESSON LEARNED]
Date: 2025-07-26 21:38:00
Topic: Unintended Modification of Core Files During Testing

Occurrence:
During troubleshooting of an infinite loop in `enhanced_task_manager.sh`, a mock version of `send_prompt.sh` was created to isolate the issue. This mock file was intended for temporary use during testing but was almost submitted to the main repository. This would have replaced a critical core script with a non-functional mock, severely impacting the application.

Remediation:
The incident was caught before submission, and the original `send_prompt.sh` was restored. To prevent this in the future, the following mitigation steps will be taken:
1.  **Use of Test-Specific Mocking:** When a mock is required for a test, it should be created with a unique name (e.g., `send_prompt.mock.sh`) and placed in a dedicated test directory. The test script should then be explicitly configured to use this mock, for example by temporarily setting an environment variable to point to the mock script.
2.  **Automated Verification:** Before submitting, a pre-commit hook or a CI/CD pipeline step could be implemented to check for any modifications to critical core scripts. This would act as a safety net to prevent accidental changes from being merged.
3.  **Clearer Communication:** When using mock scripts or other temporary test setups, it is crucial to clearly communicate the purpose and intended lifespan of these files. This will help prevent misunderstandings and ensure that temporary files are not mistaken for permanent changes.
